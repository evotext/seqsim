

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>seqsim package &mdash; seqsim 0.3 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="seqsim" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> seqsim
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Modules</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">seqsim package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-seqsim.common">seqsim.common module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-seqsim.compression">seqsim.compression module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-seqsim.edit">seqsim.edit module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-seqsim.ngrams">seqsim.ngrams module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-seqsim.sequence">seqsim.sequence module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-seqsim.token">seqsim.token module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-seqsim">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">seqsim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">seqsim</a> &raquo;</li>
        
      <li>seqsim package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/source/seqsim.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="seqsim-package">
<h1>seqsim package<a class="headerlink" href="#seqsim-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-seqsim.common">
<span id="seqsim-common-module"></span><h2>seqsim.common module<a class="headerlink" href="#module-seqsim.common" title="Permalink to this headline">¶</a></h2>
<p>Common functions.</p>
<dl class="py function">
<dt id="seqsim.common.collect_subseqs">
<code class="sig-prename descclassname"><span class="pre">seqsim.common.</span></code><code class="sig-name descname"><span class="pre">collect_subseqs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#seqsim.common.collect_subseqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects all possible sub-sequences in a given sequence.</p>
<p>When sorting is requested, sub-sequences will first be sorted by their length and,
later, by comparing one with the other. Mixing types, like strings and integers, can
lead to unexpected results and is not suggested if the type cannot be guaranteed.</p>
<p>Note that this function performs simple comprehensions, neither using padding
symbols nor the more complex methods n-gram collection methods ultimately based on
<cite>ngram_iter()</cite>.</p>
<p class="rubric">Examples</p>
<p>collect_subseqs(‘abcde’)
[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘ab’, ‘bc’, ‘cd’, ‘de’, ‘abc’, ‘bcd’, ‘cde’, ‘abcd’, ‘bcde’, ‘abcde’]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> – The sequence that shall be converted into it’s ngram-representation.</p></li>
<li><p><strong>sort</strong> – Whether to sort the list of ngrams by length and by identity
(default: True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of all ngrams of the input sequence.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.common.equivalent_string">
<code class="sig-prename descclassname"><span class="pre">seqsim.common.</span></code><code class="sig-name descname"><span class="pre">equivalent_string</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#seqsim.common.equivalent_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string equivalent to a sequence, for comparison.</p>
<p>As some methods offered by third-party libraries only operate on
strings, while <cite>seqsim</cite> is designed to offer all methods of
comparison for generic sequences of hashable elements, in
some cases it is necessary to convert a sequence to an equivalent
string. Using a normal <cite>str</cite> conversion is not possible or
satisfactory for a number of reasons, including elements not
having a string representation, and individual string
representations of different lengths and potentially overlapping
(consider cases like <cite>[1, 12, 123, 23]</cite>).</p>
<p>This function accepts a pair of sequences and returns an equivalent
textual representation, that is, a pair of strings where the
order is preserved and each token is mapped to a single, unique
character. While the information in the strings is meaningless,
they are built to facilitate inspection and debugging as much
as possible, trying to use only ASCII printable characters or
Unicode characters that are expected to be supported for
visualization in the majority of systems.</p>
<p>If two strings are passed, the same strings will be returned. Note
that in case of mixed types (such as a string and a list of
strings), strings will be considered sequences of characters
and will be modified upon return, as the tokens of the
second sequence could be of length over one character (e.g.,
<cite>“abc”</cite> and <cite>[“a”, “bc”]</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be mapped to an equivalent
string.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be mapped to an equivalent
string.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tuple of two strings equivalent, for matters of
comparison and distance computation, to the provided
sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.common.sequence_find">
<code class="sig-prename descclassname"><span class="pre">seqsim.common.</span></code><code class="sig-name descname"><span class="pre">sequence_find</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hay</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">needle</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#seqsim.common.sequence_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index for starting index of a sub-sequence within a sequence.</p>
<p>The function is intended to work similarly to the built-in <cite>.find()</cite> method for
Python strings, but accepting all types of sequences (including different types
for <cite>hay</cite> and <cite>needle</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hay</strong> – The sequence to be searched within.</p></li>
<li><p><strong>needle</strong> – The sub-sequence to be located in the sequence.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The starting index of the sub-sequence in the sequence, or <cite>None</cite> if not
found.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.common.set_seeds">
<code class="sig-prename descclassname"><span class="pre">seqsim.common.</span></code><code class="sig-name descname"><span class="pre">set_seeds</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">float</span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">None</span><a class="headerlink" href="#seqsim.common.set_seeds" title="Permalink to this definition">¶</a></dt>
<dd><p>Set seeds globally from the one provided by the user.</p>
<p>The function takes care of reproducibility and allows to use strings and
floats as seed for <cite>numpy</cite> as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> – The seed for Python and numpy random number generators.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-seqsim.compression">
<span id="seqsim-compression-module"></span><h2>seqsim.compression module<a class="headerlink" href="#module-seqsim.compression" title="Permalink to this headline">¶</a></h2>
<p>Module implementing various methods for similarity and distance from compression methods.</p>
<p>Most of the methods are commonly used in string comparison from normalized
compression distance, such as from Arithmetic Coding, but in this module we need
to make sure we can operate on arbitrary iterable data structures.</p>
<dl class="py function">
<dt id="seqsim.compression.arith_ncd">
<code class="sig-prename descclassname"><span class="pre">seqsim.compression.</span></code><code class="sig-name descname"><span class="pre">arith_ncd</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.compression.arith_ncd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between two sequences based on Arithmetic Coding.</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Arithmetic_coding">https://en.wikipedia.org/wiki/Arithmetic_coding</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Arithmetic Coding NCD between the two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.compression.entropy_ncd">
<code class="sig-prename descclassname"><span class="pre">seqsim.compression.</span></code><code class="sig-name descname"><span class="pre">entropy_ncd</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.compression.entropy_ncd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between two sequences based on entropy.</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory">https://en.wikipedia.org/wiki/Entropy_(information_theory</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Entropy NCD between the two sequences.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-seqsim.edit">
<span id="seqsim-edit-module"></span><h2>seqsim.edit module<a class="headerlink" href="#module-seqsim.edit" title="Permalink to this headline">¶</a></h2>
<p>Module implementing various methods for similarity and distance from edit methods.</p>
<p>Most of the methods are commonly used in string comparison, such as Levenshtein
distance, but in this module we need to make sure we can operate on arbitrary
iterable data structures.</p>
<dl class="py function">
<dt id="seqsim.edit.birnbaum_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">birnbaum_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.birnbaum_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Birnbaum similarity distance with the original method.</p>
<p>This implementation uses the original method we developed following
the description in Birnbaum (2003). See comments for <cite>birnbaum_simil()</cite>.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Jaccard distance is already
in range [0..1].</p>
<dl class="simple">
<dt>See: Birnbaum, David J. (2003). “Computer-Assisted Analysis and</dt><dd><p>Study of the Structure of Mixed-Content Miscellanies”.
Scripta &amp; Scripta 1:15-64.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between the two sequences. A distance of 0.0 indicates
identical sequences, and a distance of 1.0 indicates the maximum
theoretical distance between two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.birnbaum_simil">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">birnbaum_simil</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.birnbaum_simil" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Birnbaum similarity score with the original method.</p>
<p>This implementation uses the method first developed for Göransson et al.,
following the description in Birnbaum (2003). Note that, on large
sequences, it is much slower and more memory-intensive than the one
implemented in the <cite>fast_birnbaum_simil</cite> method.  While in most cases
the results are comparable, particularly after scaling/normalization,
the values are <em>not</em> identical.</p>
<dl class="simple">
<dt>See: Birnbaum, David J. (2003). “Computer-Assisted Analysis and</dt><dd><p>Study of the Structure of Mixed-Content Miscellanies”.
Scripta &amp; Scripta 1:15-64.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Whether to normalize the similarity score in range
[0..1] using sequence lengths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The similarity score between the two sequences. The higher
the similarity score, the more similar the two sequences are;
a similarity score of zero is the theoretical maximum difference
between two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.bulk_delete_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">bulk_delete_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_del_len</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.bulk_delete_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the “bulk delete” distance between two sequences.</p>
<p>This function will use the standard Wagner-Fischer algorithm with the
default costs provided by the internal <cite>_levdamerau_costs()</cite>
function. This distance measure is not used directly in the paper and was a
proof-of-concept while working toward the “Stemmatological distance”.</p>
<dl class="simple">
<dt>See: Göransson, Elisabet; Maurits, Luke; Dahlman, Britt; Sarkisian, Karine Å.;</dt><dd><p>Rubenson, Samuel; Dunn, Michael. “Improved distance measures for ‘mixed-content
miscellania’ (in prep.).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>max_del_len</strong> – The maximum length of deletion block.</p></li>
<li><p><strong>normal</strong> – Whether to normalize the similarity score in range
[0..1] using sequence lengths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The computed “bulk delete” distance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.fast_birnbaum_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">fast_birnbaum_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.fast_birnbaum_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Birnbaum similarity distance with the fast method.</p>
<p>This implementation uses the experimental method we developed following
the description in Birnbaum (2003), which is much faster and less
memory-intensive than the one implemented in the <cite>birnbaum()</cite>
method. While in most cases the results are comparable, and the ones
provided by this method might be considered more adequate due to their
handling of duplicate information, the values are <em>not</em> identical.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Jaccard distance is already
in range [0..1].</p>
<dl class="simple">
<dt>See: Birnbaum, David J. (2003). “Computer-Assisted Analysis and</dt><dd><p>Study of the Structure of Mixed-Content Miscellanies”.
Scripta &amp; Scripta 1:15-64.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between the two sequences. A distance of 0.0 indicates
identical sequences, and a distance of 1.0 indicates the maximum
theoretical distance between two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.fast_birnbaum_simil">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">fast_birnbaum_simil</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.fast_birnbaum_simil" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Birnbaum similarity score with the fast method.</p>
<p>This implementation uses the experimental method we developed following
the description in Birnbaum (2003), which is much faster and less
memory-intensive than the one implemented in the <cite>birnbaum_simil()</cite>
function. While in most cases the results are comparable, particularly
after scaling/normalization, and while the ones
provided by this method might be considered more adequate due to their
handling of duplicate information, the values are <em>not</em> identical.</p>
<dl class="simple">
<dt>See: Birnbaum, David J. (2003). “Computer-Assisted Analysis and</dt><dd><p>Study of the Structure of Mixed-Content Miscellanies”.
Scripta &amp; Scripta 1:15-64.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Whether to normalize the similarity score in range
[0..1] using sequence lengths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The similarity score between the two sequences. The higher
the similarity score, the more similar the two sequences are;
a similarity score of zero is the theoretical maximum difference
between two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.fragile_ends_simil">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">fragile_ends_simil</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.fragile_ends_simil" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the “fragile ends” similarity between two sequences.</p>
<p>The “fragile ends” similarity is defined as equal to the Levenshtein one,
but with deletions in the initial or final 10% of the positions being
discounted.</p>
<p>This function will use the standard Wagner-Fischer algorithm with the
default costs provided by the internal <cite>_levdamerau_costs()</cite>
function. This similarity measure is not used directly in the paper and was a
proof-of-concept while working toward the “Stemmatological distance”.</p>
<dl class="simple">
<dt>See: Göransson, Elisabet; Maurits, Luke; Dahlman, Britt; Sarkisian, Karine Å.;</dt><dd><p>Rubenson, Samuel; Dunn, Michael. “Improved distance measures for ‘mixed-content
miscellania’ (in prep.).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Whether to normalize the similarity score in range
[0..1] using sequence lengths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The computed “fragile ends” similarity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.jaro_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">jaro_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.jaro_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Jaro distance between two sequences.</p>
<p>This function returns the value from the implementation provided by
the <cite>textdistance</cite> library.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Jaccard distance is already
in range [0..1].</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence of elements to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence of elements to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Jaro distance between the two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.jaro_winkler_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">jaro_winkler_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.jaro_winkler_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Jaro-Winkler distance between two sequences.</p>
<p>This function returns the value from the implementation provided by
the <cite>textdistance</cite> library.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Jaccard distance is already
in range [0..1].</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence of elements to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence of elements to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Jaro-Winkler distance between the two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.levdamerau_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">levdamerau_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.levdamerau_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Damerau-Levenshtein distance between two sequences.</p>
<p>This function will use the standard Wagner-Fischer algorithm with the
default costs provided by the internal <cite>_levdamerau_costs()</cite>
function.</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Whether to normalize the similarity score in range
[0..1] using sequence lengths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The computed Levenshtein distance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.levenshtein_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">levenshtein_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.levenshtein_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Levenshtein distance between two sequences.</p>
<p>This function will use the standard Wagner-Fischer algorithm with the
default costs provided by the internal <cite>_levenshtein_costs()</cite>
function.</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Levenshtein_distance">https://en.wikipedia.org/wiki/Levenshtein_distance</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Whether to normalize the similarity score in range
[0..1] using sequence lengths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The computed Levenshtein distance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.mmcwpa_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">mmcwpa_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.mmcwpa_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an MMCWPA distance between two sequences.</p>
<p>MMCWPA is the Modifier Moving Contracting Window Pattern Algorithm, modified by
Tiago Tresoldi from a method published by Yang et al. (2001). In order to simplify
the logic, the function uses the auxiliary internal function <cite>_mmcwpa()</cite>.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Jaccard distance is already
in range [0..1].</p>
<p>See: Yang, Q. X.; Yuan, Sung S.; Chun, Lu; Zhao, Li; Peng Sun. “Faster Algorithm of String
Comparison”, eprint arXiv:cs/0112022, December 2001.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence of elements to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence of elements to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The MMCWPA distance between the two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.edit.stemmatological_simil">
<code class="sig-prename descclassname"><span class="pre">seqsim.edit.</span></code><code class="sig-name descname"><span class="pre">stemmatological_simil</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frag_start</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frag_end</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_del_len</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.edit.stemmatological_simil" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the “stemmatological” similarity between two sequences.</p>
<p>This function will use the standard Wagner-Fischer algorithm with the
default costs provided by the internal <cite>_levdamerau_costs()</cite>
function. This similarity measure is essentially a combination of the
“fragile ends” and “bulk delete” methods, with the first one
generalised a little to allow specifying the size of both fragile regions.</p>
<dl class="simple">
<dt>See: Göransson, Elisabet; Maurits, Luke; Dahlman, Britt; Sarkisian, Karine Å.;</dt><dd><p>Rubenson, Samuel; Dunn, Michael. “Improved distance measures for ‘mixed-content
miscellania’ (in prep.).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>max_del_len</strong> – The maximum length of deletion block.</p></li>
<li><p><strong>frag_start</strong> – </p></li>
<li><p><strong>frag_end</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>.param normal: Whether to normalize the similarity score in range</dt><dd><p>[0..1] using sequence lengths.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The computed “stemmatological” similarity.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-seqsim.ngrams">
<span id="seqsim-ngrams-module"></span><h2>seqsim.ngrams module<a class="headerlink" href="#module-seqsim.ngrams" title="Permalink to this headline">¶</a></h2>
<p>Module for collecting ngrams on sequences of arbitrary elements.</p>
<p>Most of the code in this module follows the original implementation by Tiago Tresoldi
for the <cite>lingpy</cite> library, later moved into the independent <cite>lpngram</cite> package.</p>
<dl class="py function">
<dt id="seqsim.ngrams.get_all_ngrams_by_order">
<code class="sig-prename descclassname"><span class="pre">seqsim.ngrams.</span></code><code class="sig-name descname"><span class="pre">get_all_ngrams_by_order</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orders</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'$$$'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seqsim.ngrams.get_all_ngrams_by_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Build an iterator for collecting all ngrams of a given set of orders.
If no set of orders (i.e., “lengths”) is provided, this will collect all
possible ngrams in the sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> – The sequence from which the ngrams will be collected.</p></li>
<li><p><strong>orders</strong> – An optional list of the orders of the ngrams to be collected. Can be
larger than the length of the sequence, in which case the latter will
be padded accordingly if requested. Defaults to the collection of all
possible ngrams in the sequence with the minimum padding.</p></li>
<li><p><strong>pad_symbol</strong> – An optional symbol to be used as start-of- and end-of-sequence
boundaries. The same symbol is used for both boundaries. Must be a
value different from None, defaults to “$$$”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An iterable over the ngrams of the sequence, returned as tuples.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.ngrams.ngrams_iter">
<code class="sig-prename descclassname"><span class="pre">seqsim.ngrams.</span></code><code class="sig-name descname"><span class="pre">ngrams_iter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_symbol</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'$$$'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seqsim.ngrams.ngrams_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Build an iterator for collecting all ngrams of a given order.
The sequence can optionally be padded with boundary symbols which are
equal for before and and after sequence boundaries.
:param sequence: The sequence from which the ngrams will be collected.
:param order: The order of the ngrams to be collected.
:param pad_symbol: An optional symbol to be used as start-of- and end-of-sequence</p>
<blockquote>
<div><p>boundaries. The same symbol is used for both boundaries. Must be a
value different from None, defaults to “$$$”.</p>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-seqsim.sequence">
<span id="seqsim-sequence-module"></span><h2>seqsim.sequence module<a class="headerlink" href="#module-seqsim.sequence" title="Permalink to this headline">¶</a></h2>
<p>Module implementing various methods for similarity and distance from sequence methods.</p>
<p>Most of the methods are commonly used in string comparison, such as
RatcliffObershelp, but in this module we need to make sure we can operate on arbitrary
iterable data structures.</p>
<dl class="py function">
<dt id="seqsim.sequence.ratcliff_obershelp">
<code class="sig-prename descclassname"><span class="pre">seqsim.sequence.</span></code><code class="sig-name descname"><span class="pre">ratcliff_obershelp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.sequence.ratcliff_obershelp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between two sequences based on the Ratcliff-Obershelp similarity.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Ratcliff-Obershelp distance is already
in range [0..1].</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Gestalt_Pattern_Matching">https://en.wikipedia.org/wiki/Gestalt_Pattern_Matching</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Ratcliff-Obershelp distance between the two sequences.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-seqsim.token">
<span id="seqsim-token-module"></span><h2>seqsim.token module<a class="headerlink" href="#module-seqsim.token" title="Permalink to this headline">¶</a></h2>
<p>Module implementing various methods for similarity and distance from token methods.</p>
<p>Most of the methods are commonly used in string comparison, such as Jaccard
index, but in this module we need to make sure we can operate on arbitrary
iterable data structures.</p>
<dl class="py function">
<dt id="seqsim.token.jaccard_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.token.</span></code><code class="sig-name descname"><span class="pre">jaccard_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.token.jaccard_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a Jaccard distance between two sequences.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Jaccard distance is already
in range [0..1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Jaccard distance between the two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.token.sorensen_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.token.</span></code><code class="sig-name descname"><span class="pre">sorensen_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.token.sorensen_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a distance between two sequences based on the Sørensen–Dice coefficient.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Sørensen–Dice distance is already
in range [0..1].</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient">https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Sørensen–Dice distance between the two sequences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.token.subseq_jaccard_dist">
<code class="sig-prename descclassname"><span class="pre">seqsim.token.</span></code><code class="sig-name descname"><span class="pre">subseq_jaccard_dist</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_x</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq_y</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.token.subseq_jaccard_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a Jaccard distance between two sequences using sub-sequence occurrence.</p>
<p>The function accepts the <cite>normal</cite> parameter to have calls equivalent to those
of other methods, but it is redundant as the Jaccard distance is already
in range [0..1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_x</strong> – The first sequence to be compared.</p></li>
<li><p><strong>seq_y</strong> – The second sequence to be compared.</p></li>
<li><p><strong>normal</strong> – Dummy parameter, see comment above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Subseq-Jaccard distance between the two sequences.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-seqsim">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-seqsim" title="Permalink to this headline">¶</a></h2>
<p>seqsim __init__.py</p>
<p>We follow the mathematical definitions for distinguishing between “similarity”
and “distance”, as the latter must have the following properties:</p>
<blockquote>
<div><ul class="simple">
<li><p>positivity: d(x,y) &gt;= 0</p></li>
<li><p>symmetry: d(x,y) = d(y,x)</p></li>
<li><p>identity-discerning: d(x,y) = 0 =&gt; x = y</p></li>
<li><p>triangle inequality: d(x,z) &lt;= d(x,y) + d(y,z)</p></li>
</ul>
</div></blockquote>
<dl class="py function">
<dt id="seqsim.collect_subseqs">
<code class="sig-prename descclassname"><span class="pre">seqsim.</span></code><code class="sig-name descname"><span class="pre">collect_subseqs</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#seqsim.collect_subseqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects all possible sub-sequences in a given sequence.</p>
<p>When sorting is requested, sub-sequences will first be sorted by their length and,
later, by comparing one with the other. Mixing types, like strings and integers, can
lead to unexpected results and is not suggested if the type cannot be guaranteed.</p>
<p>Note that this function performs simple comprehensions, neither using padding
symbols nor the more complex methods n-gram collection methods ultimately based on
<cite>ngram_iter()</cite>.</p>
<p class="rubric">Examples</p>
<p>collect_subseqs(‘abcde’)
[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘ab’, ‘bc’, ‘cd’, ‘de’, ‘abc’, ‘bcd’, ‘cde’, ‘abcd’, ‘bcde’, ‘abcde’]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> – The sequence that shall be converted into it’s ngram-representation.</p></li>
<li><p><strong>sort</strong> – Whether to sort the list of ngrams by length and by identity
(default: True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of all ngrams of the input sequence.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.distance">
<code class="sig-prename descclassname"><span class="pre">seqsim.</span></code><code class="sig-name descname"><span class="pre">distance</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'levenshtein'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">float</span><a class="headerlink" href="#seqsim.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distance between sequences according to a specified method.</p>
<p>This function acts as a wrapper to all the methods offered by the package,
including those that are not properly “distances” but measures of
“similarity” (that is, those that do not offer all the distance
properties). It is intended as a single point of call for all the
methods that are offered.</p>
<p>Contrary to the individual methods that accept two sequence as arguments,
this wrapper accepts a sequence of sequence, allowing to compute
multiple distances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seqs</strong> – A group of group of hashable elements to be compared.
Currently, if more than two sequences are passed, it just returns
the mean value of all pairwise comparisons, but this operation
might change in the future at least for some methods.</p></li>
<li><p><strong>method</strong> – The method for comparison to be used. The list of
methods, and the function they call, can be obtained from the
keys of the <cite>METHODS</cite> dictionary exported by this module.
Defaults to “levenshtein”.</p></li>
<li><p><strong>normal</strong> – Whether to return a normalized score for the comparison
in range [0..1]. Note that the function will accept a <cite>True</cite> value
for all methods, but not all methods offer normalization and some
method always return normalized values. In those cases, the
standard value will be returned a warning message will be sent
to the standard logger (which can be silenced as usual with the
Python <cite>logging</cite> standard library. Defaults to <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance score.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.get_all_ngrams_by_order">
<code class="sig-prename descclassname"><span class="pre">seqsim.</span></code><code class="sig-name descname"><span class="pre">get_all_ngrams_by_order</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orders</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'$$$'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seqsim.get_all_ngrams_by_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Build an iterator for collecting all ngrams of a given set of orders.
If no set of orders (i.e., “lengths”) is provided, this will collect all
possible ngrams in the sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> – The sequence from which the ngrams will be collected.</p></li>
<li><p><strong>orders</strong> – An optional list of the orders of the ngrams to be collected. Can be
larger than the length of the sequence, in which case the latter will
be padded accordingly if requested. Defaults to the collection of all
possible ngrams in the sequence with the minimum padding.</p></li>
<li><p><strong>pad_symbol</strong> – An optional symbol to be used as start-of- and end-of-sequence
boundaries. The same symbol is used for both boundaries. Must be a
value different from None, defaults to “$$$”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An iterable over the ngrams of the sequence, returned as tuples.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="seqsim.ngrams_iter">
<code class="sig-prename descclassname"><span class="pre">seqsim.</span></code><code class="sig-name descname"><span class="pre">ngrams_iter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_symbol</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'$$$'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seqsim.ngrams_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Build an iterator for collecting all ngrams of a given order.
The sequence can optionally be padded with boundary symbols which are
equal for before and and after sequence boundaries.
:param sequence: The sequence from which the ngrams will be collected.
:param order: The order of the ngrams to be collected.
:param pad_symbol: An optional symbol to be used as start-of- and end-of-sequence</p>
<blockquote>
<div><p>boundaries. The same symbol is used for both boundaries. Must be a
value different from None, defaults to “$$$”.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="seqsim.set_seeds">
<code class="sig-prename descclassname"><span class="pre">seqsim.</span></code><code class="sig-name descname"><span class="pre">set_seeds</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">float</span><span class="p"><span class="pre">,</span> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">None</span><a class="headerlink" href="#seqsim.set_seeds" title="Permalink to this definition">¶</a></dt>
<dd><p>Set seeds globally from the one provided by the user.</p>
<p>The function takes care of reproducibility and allows to use strings and
floats as seed for <cite>numpy</cite> as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> – The seed for Python and numpy random number generators.</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="modules.html" class="btn btn-neutral float-left" title="seqsim" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Tiago Tresoldi, Luke Maurits, Michael Dunn.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>